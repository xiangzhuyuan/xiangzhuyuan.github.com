---
layout: post
title: JAVA生成和解析XML的四种方法比较
date: 2009-10-27 18:42
comments: true
categories: []
---
<p>许海潮的专栏<br/>
 <br/>
XML现在已经成为一种通用的数据交换格式,它的平台无关性,语言无关性,系统无关性,给数据集成与交互带来了极大的方便。对于XML本身的语法知识与技术细节,需要阅读相关的技术文献,这里面包括的内容有DOM(Document
Object Model),DTD(Document Type Definition),SAX(Simple API for
XML),XSD(Xml Schema Definition),XSLT(Extensible Stylesheet Language
Transformations),具体可参阅w3c官方网站文档<a href="http://www.w3.org">http://www.w3.org</a>获取更多信息。</p>
<p>
       
XML在不同的语言里解析方式都是一样的,只不过实现的语法不同而已。基本的解析方式有两种,一种叫SAX，另一种叫DOM。SAX是基于事件流的解析,DOM是基于XML文档树结构的解析。假设我们XML的内容和结构如下:</p>
<p><?xml version=”1.0″
encoding=”UTF-8″?><br/>
<employees><br/>
  <employee><br/>
   
<name>ddviplinux</name><br/>

   
<sex>m</sex><br/>

   
<age>30</age><br/>

  </employee><br/>
</employees></p>
<p>本文使用JAVA语言来实现DOM与SAX的XML文档生成与解析。</p>
<p>首先定义一个操作XML文档的接口XmlDocument 它定义了XML文档的建立与解析的接口。</p>
<p>package com.alisoft.facepay.framework.bean;</p>
<p> </p>
<p>public interface XmlDocument {</p>
<p> </p>
<p>public void createXml(String fileName);</p>
<p> </p>
<p>public void parserXml(String fileName);</p>
<p>}</p>
<p>1. DOM生成和解析XML文档</p>
<p>
       
为 XML 文档的已解析版本定义了一组接口。解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用 DOM
接口来操作这个树结构。优点：整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能；缺点：将整个文档调入内存（包括无用的节点），浪费时间和空间；使用场合：一旦解析了文档还需多次访问这些数据；硬件资源充足（内存、CPU）。</p>
<p>package com.alisoft.facepay.framework.bean;</p>
<p>import java.io.FileInputStream;</p>
<p>import java.io.FileNotFoundException;</p>
<p>import java.io.FileOutputStream;</p>
<p>import java.io.IOException;</p>
<p>import java.io.InputStream;</p>
<p>import java.io.PrintWriter;</p>
<p>import javax.xml.parsers.DocumentBuilder;</p>
<p>import javax.xml.parsers.DocumentBuilderFactory;</p>
<p>import javax.xml.parsers.ParserConfigurationException;</p>
<p>import javax.xml.transform.OutputKeys;</p>
<p>import javax.xml.transform.Transformer;</p>
<p>import
javax.xml.transform.TransformerConfigurationException;</p>
<p>import javax.xml.transform.TransformerException;</p>
<p>import javax.xml.transform.TransformerFactory;</p>
<p>import javax.xml.transform.dom.DOMSource;</p>
<p>import javax.xml.transform.stream.StreamResult;</p>
<p>import org.w3c.dom.Document;</p>
<p>import org.w3c.dom.Element;</p>
<p>import org.w3c.dom.Node;</p>
<p>import org.w3c.dom.NodeList;</p>
<p>import org.xml.sax.SAXException;</p>
<p> </p>
<p>public class DomDemo implements XmlDocument {</p>
<p>   </p>
<p>    private
Document document;</p>
<p> </p>
<p>    private
String fileName;</p>
<p> </p>
<p>    public
void init() {</p>
<p>
      
try {</p>
<p>
          
DocumentBuilderFactory factory = DocumentBuilderFactory</p>
<p>
                 
.newInstance();</p>
<p>
          
DocumentBuilder builder = factory.newDocumentBuilder();</p>
<p>
          
this.document = builder.newDocument();</p>
<p>
      
} catch (ParserConfigurationException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
}</p>
<p>    }</p>
<p> </p>
<p>    public
void createXml(String fileName) {</p>
<p> </p>
<p>
      
Element root = this.document.createElement_x(“employees”);</p>
<p>
      
this.document.appendChild(root);</p>
<p>
      
Element employee = this.document.createElement_x(“employee”);</p>
<p>
      
Element name = this.document.createElement_x(“name”);</p>
<p>
      
name.appendChild(this.document.createTextNode(“丁宏亮“));</p>
<p>
      
employee.appendChild(name);</p>
<p>
      
Element sex = this.document.createElement_x(“sex”);</p>
<p>
      
sex.appendChild(this.document.createTextNode(“m”));</p>
<p>
      
employee.appendChild(sex);</p>
<p>
      
Element age = this.document.createElement_x(“age”);</p>
<p>
      
age.appendChild(this.document.createTextNode(“30″));</p>
<p>
      
employee.appendChild(age);</p>
<p>
      
root.appendChild(employee);</p>
<p> </p>
<p>
      
TransformerFactory tf = TransformerFactory.newInstance();</p>
<p>
      
try {</p>
<p>
          
Transformer transformer = tf.newTransformer();</p>
<p>
          
DOMSource source = new DOMSource(document);</p>
<p>
          
transformer.setOutputProperty(OutputKeys.ENCODING, “gb2312″);</p>
<p>
          
transformer.setOutputProperty(OutputKeys.INDENT, “yes”);</p>
<p>
          
PrintWriter pw = new PrintWriter(new
FileOutputStream(fileName));</p>
<p>
          
StreamResult result = new StreamResult(pw);</p>
<p>
          
transformer.transform(source, result);</p>
<p>
          
System.out.println(“生成XML文件成功!”);</p>
<p>
      
} catch (TransformerConfigurationException e) {</p>
<p> </p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (IllegalArgumentException e) {</p>
<p> </p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (FileNotFoundException e) {</p>
<p> </p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (TransformerException e) {</p>
<p> </p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
}</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void parserXml(String fileName) {</p>
<p>
      
try {</p>
<p>
          
DocumentBuilderFactory dbf =
DocumentBuilderFactory.newInstance();</p>
<p>
          
DocumentBuilder db = dbf.newDocumentBuilder();</p>
<p>
          
Document document = db.parse(fileName);</p>
<p>
          
NodeList employees = document.getChildNodes();</p>
<p>
          
for (int i = 0; i < employees.getLength(); i++)
{</p>
<p>
             
Node employee = employees.item(i);</p>
<p>
             
NodeList employeeInfo = employee.getChildNodes();</p>
<p>
             
for (int j = 0; j < employeeInfo.getLength(); j++)
{</p>
<p>
                 
Node node = employeeInfo.item(j);</p>
<p>
                 
NodeList employeeMeta = node.getChildNodes();</p>
<p>
                 
for (int k = 0; k < employeeMeta.getLength(); k++)
{</p>
<p>
                    
System.out.println(employeeMeta.item(k).getNodeName()</p>
<p>
                           
+ “:” + employeeMeta.item(k).getTextdescription());</p>
<p>
                 
}</p>
<p>
             
}</p>
<p>
          
}</p>
<p>
          
System.out.println(“解析完毕“);</p>
<p>
      
} catch (FileNotFoundException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (ParserConfigurationException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (SAXException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
} catch (IOException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
}</p>
<p>
    
}</p>
<p>}</p>
<p>2. SAX生成和解析XML文档</p>
<p>
       
为解决DOM的问题，出现了SAX。SAX
，事件驱动。当解析器发现元素开始、元素结束、文本、文档的开始或结束等时，发送事件，程序员编写响应这些事件的代码，保存数据。优点：不用事先调入整个文档，占用资源少；SAX解析器代码比DOM解析器代码小，适于Applet，下载。缺点：不是持久的；事件过后，若没保存数据，那么数据就丢了；无状态性；从事件中只能得到文本，但不知该文本属于哪个元素；使用场合：Applet;只需XML文档的少量内容，很少回头访问；机器内存少；</p>
<p>package com.alisoft.facepay.framework.bean;</p>
<p>import java.io.FileInputStream;</p>
<p>import java.io.FileNotFoundException;</p>
<p>import java.io.IOException;</p>
<p>import java.io.InputStream;</p>
<p>import javax.xml.parsers.ParserConfigurationException;</p>
<p>import javax.xml.parsers.SAXParser;</p>
<p>import javax.xml.parsers.SAXParserFactory;</p>
<p>import org.xml.sax.Attributes;</p>
<p>import org.xml.sax.SAXException;</p>
<p>import org.xml.sax.helpers.DefaultHandler;</p>
<p> </p>
<p>public class SaxDemo implements XmlDocument {</p>
<p> </p>
<p>    public
void createXml(String fileName) {</p>
<p>
       
System.out.println(“<<”+filename+“>>”);</p>
<p>    }</p>
<p> </p>
<p>    public
void parserXml(String fileName) {</p>
<p>
      
SAXParserFactory saxfac = SAXParserFactory.newInstance();</p>
<p> </p>
<p>
      
try {</p>
<p> </p>
<p>
          
SAXParser saxparser = saxfac.newSAXParser();</p>
<p> </p>
<p>
          
InputStream is = new FileInputStream(fileName);</p>
<p> </p>
<p>
          
saxparser.parse(is, new MySAXHandler());</p>
<p> </p>
<p>
      
} catch (ParserConfigurationException e) {</p>
<p> </p>
<p>
          
e.printStackTrace();</p>
<p> </p>
<p>
      
} catch (SAXException e) {</p>
<p> </p>
<p>
          
e.printStackTrace();</p>
<p> </p>
<p>
      
} catch (FileNotFoundException e) {</p>
<p> </p>
<p>
          
e.printStackTrace();</p>
<p> </p>
<p>
      
} catch (IOException e) {</p>
<p> </p>
<p>
          
e.printStackTrace();</p>
<p> </p>
<p>
      
}</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>}</p>
<p> </p>
<p>class MySAXHandler extends DefaultHandler {</p>
<p> </p>
<p>    boolean
hasAttribute = false;</p>
<p> </p>
<p>   
Attributes attributes = null;</p>
<p> </p>
<p>    public
void startDocument() throws SAXException {</p>
<p> </p>
<p>
      
System.out.println(“文档开始打印了“);</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void endDocument() throws SAXException {</p>
<p> </p>
<p>
      
System.out.println(“文档打印结束了“);</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void startElement(String uri, String localName, String qName,</p>
<p> </p>
<p>   
Attributes attributes) throws SAXException {</p>
<p> </p>
<p>
      
if (qName.equals(“employees”)) {</p>
<p> </p>
<p>
          
return;</p>
<p> </p>
<p>
      
}</p>
<p> </p>
<p>
      
if (qName.equals(“employee”)) {</p>
<p> </p>
<p>
          
System.out.println(qName);</p>
<p> </p>
<p>
      
}</p>
<p> </p>
<p>
      
if (attributes.getLength() > 0) {</p>
<p> </p>
<p>
          
this.attributes = attributes;</p>
<p> </p>
<p>
          
this.hasAttribute = true;</p>
<p> </p>
<p>
      
}</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void endElement(String uri, String localName, String qName)</p>
<p> </p>
<p>    throws
SAXException {</p>
<p> </p>
<p>
      
if (hasAttribute && (attributes !=
null)) {</p>
<p> </p>
<p>
          
for (int i = 0; i < attributes.getLength(); i++)
{</p>
<p> </p>
<p>
             
System.out.println(attributes.getQName(0)</p>
<p>
                    
+ attributes.getValue(0));</p>
<p> </p>
<p>
          
}</p>
<p> </p>
<p>
      
}</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void characters(char[] ch, int start, int length)</p>
<p> </p>
<p>    throws
SAXException {</p>
<p> </p>
<p>
      
System.out.println(new String(ch, start, length));</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>}</p>
<p>3. DOM4J生成和解析XML文档</p>
<p>
        
DOM4J 是一个非常非常优秀的Java XML
API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的 Java 软件都在使用
DOM4J 来读写 XML，特别值得一提的是连 Sun 的 JAXM 也在用 DOM4J。</p>
<p>package com.alisoft.facepay.framework.bean;</p>
<p>import java.io.File;</p>
<p>import java.io.FileWriter;</p>
<p>import java.io.IOException;</p>
<p>import java.io.Writer;</p>
<p>import java.util.Iterator;</p>
<p>import org.dom4j.Document;</p>
<p>import org.dom4j.DocumentException;</p>
<p>import org.dom4j.DocumentHelper;</p>
<p>import org.dom4j.Element;</p>
<p>import org.dom4j.io.SAXReader;</p>
<p>import org.dom4j.io.XMLWriter;</p>
<p> </p>
<p>public class Dom4jDemo implements XmlDocument {</p>
<p> </p>
<p>    public
void createXml(String fileName) {</p>
<p>
      
Document document = DocumentHelper.createDocument();</p>
<p>
      
Element employees=document.addElement(“employees”);</p>
<p>
      
Element employee=employees.addElement(“employee”);</p>
<p>
      
Element name= employee.addElement(“name”);</p>
<p>
      
name.setText(“ddvip”);</p>
<p>
      
Element sex=employee.addElement(“sex”);</p>
<p>
      
sex.setText(“m”);</p>
<p>
      
Element age=employee.addElement(“age”);</p>
<p>
      
age.setText(“29″);</p>
<p>
      
try {</p>
<p>
          
Writer fileWriter=new FileWriter(fileName);</p>
<p>
          
XMLWriter xmlWriter=new XMLWriter(fileWriter);</p>
<p>
          
xmlWriter.write(document);</p>
<p>
          
xmlWriter.close();</p>
<p>
      
} catch (IOException e) {</p>
<p>
          </p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
}</p>
<p>
      </p>
<p>
      </p>
<p>    }</p>
<p> </p>
<p> </p>
<p>    public
void parserXml(String fileName) {</p>
<p>
       
File inputXml=new File(fileName);</p>
<p>
       
SAXReader saxReader = new SAXReader();</p>
<p>
       
try {</p>
<p>
          
Document document = saxReader.read(inputXml);</p>
<p>
          
Element employees=document.getRootElement();</p>
<p>
          
for(Iterator i = employees.elementIterator(); i.hasNext();){</p>
<p>
              
Element employee = (Element) i.next();</p>
<p>
              
for(Iterator j = employee.elementIterator(); j.hasNext();){</p>
<p>
                  
Element node=(Element) j.next();</p>
<p>
                  
System.out.println(node.getName()+“:”+node.getText());</p>
<p>
              
}</p>
<p> </p>
<p>
          
}</p>
<p>
      
} catch (DocumentException e) {</p>
<p>
          
System.out.println(e.getMessage());</p>
<p>
      
}</p>
<p>
    
System.out.println(“dom4j parserXml”);</p>
<p>    }</p>
<p> </p>
<p> </p>
<p>}</p>
<p>4. JDOM生成和解析XML</p>
<p>
       
为减少DOM、SAX的编码量，出现了JDOM；优点：20-80原则，极大减少了代码量。使用场合：要实现的功能简单，如解析、创建等，但在底层，JDOM还是使用SAX（最常用）、DOM、Xanan文档。</p>
<p>package com.alisoft.facepay.framework.bean;</p>
<p>import java.io.FileNotFoundException;</p>
<p>import java.io.FileOutputStream;</p>
<p>import java.io.IOException;</p>
<p>import java.util.List;</p>
<p>import org.jdom.Document;</p>
<p>import org.jdom.Element;</p>
<p>import org.jdom.JDOMException;</p>
<p>import org.jdom.input.SAXBuilder;</p>
<p>import org.jdom.output.XMLOutputter;</p>
<p> </p>
<p>public class JDomDemo implements XmlDocument {</p>
<p> </p>
<p>    public
void createXml(String fileName) {</p>
<p>
     
Document document;</p>
<p>
     
Element  root;</p>
<p>
     
root=new Element(“employees”);</p>
<p>
     
document=new Document(root);</p>
<p>
     
Element employee=new Element(“employee”);</p>
<p>
     
root.adddescription(employee);</p>
<p>
     
Element name=new Element(“name”);</p>
<p>
     
name.setText(“ddvip”);</p>
<p>
     
employee.adddescription(name);</p>
<p>
     
Element sex=new Element(“sex”);</p>
<p>
     
sex.setText(“m”);</p>
<p>
     
employee.adddescription(sex);</p>
<p>
     
Element age=new Element(“age”);</p>
<p>
     
age.setText(“23″);</p>
<p>
     
employee.adddescription(age);</p>
<p>
     
XMLOutputter XMLOut = new XMLOutputter();</p>
<p>
     
try {</p>
<p>
      
XMLOut.output(document, new FileOutputStream(fileName));</p>
<p>    } catch
(FileNotFoundException e) {</p>
<p>
      
e.printStackTrace();</p>
<p>    } catch
(IOException e) {</p>
<p>
      
e.printStackTrace();</p>
<p>    }</p>
<p> </p>
<p>    }</p>
<p> </p>
<p>    public
void parserXml(String fileName) {</p>
<p>
      
SAXBuilder builder=new SAXBuilder(false);</p>
<p>
      
try {</p>
<p>
          
Document document=builder.build(fileName);</p>
<p>
          
Element employees=document.getRootElement();</p>
<p>
          
List employeeList=employees.getChildren(“employee”);</p>
<p>
          
for(int i=0;i<employeeList.size();i++){</p>
<p>
             
Element employee=(Element)employeeList.get(i);</p>
<p>
             
List employeeInfo=employee.getChildren();</p>
<p>
             
for(int j=0;j<employeeInfo.size();j++){</p>
<p>
             
System.out.println(((Element)employeeInfo.get(j)).getName()+“:”+((Element)employeeInfo.get(j)).getValue());</p>
<p>
                 </p>
<p>
             
}</p>
<p>
          
}</p>
<p>
      
} catch (JDOMException e) {</p>
<p>
      </p>
<p>
          
e.printStackTrace();</p>
<p>
      
} catch (IOException e) {</p>
<p>
      </p>
<p>
          
e.printStackTrace();</p>
<p>
      
}</p>
<p> </p>
<p>    }</p>
<p>}</p>
<p>  </p>
<p>本文来自CSDN博客，转载请标明出处：<a href="http://blog.csdn.net/gundsoul/archive/2009/07/05/4322749.aspx">http://blog.csdn.net/gundsoul/archive/2009/07/05/4322749.aspx</a></p>
